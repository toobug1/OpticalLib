#ifndef TRESULT_H
#define TRESULT_H

#include <vector>
#include <set>

#include "Sys/tsource.h"
#include "Sys/tsurface.h"
#include "vector_pool"

class TResult
{
    friend class TTracer;

  public:
    typedef std::vector<const TSource *> sources_t;

    /** Crate a new empty result object */
    TResult();

    ~TResult();

    /** Get the list of rays striking a given surface */
    const rays_queue_t & get_intercepted(const TSurface &s) const;
    /** Get the list of rays generated by a given element */
    const rays_queue_t & get_generated(const TElement &s) const;

    /** Get list of sources used for ray tracing */
    const TResult::sources_t & get_source_list() const;

    /** Get window which include all ray intercepted on a surface */
    Math::VectorPair3 get_intercepted_window(const TSurface &s) const;
    /** Get center of window */
    Math::Vector3 get_intercepted_center(const TSurface &s) const;
    /** Get centroid of all ray intercepted on a surface */
    Math::Vector3 get_intercepted_centroid(const TSurface& s) const;

    /** Clear all result data */
    void clear();

    /** List of rays striking this surface must be saved when tracing rays */
    void set_intercepted_save_state(const TElement &e, bool enabled = true);
    /** Return true if generated rays must be saved for this element */
    bool get_intercepted_save_state(const TElement &e);

    /** List of rays generated by this element must be saved when tracing rays */
    void set_generated_save_state(const TElement &e, bool enabled = true);
    /** Return true if generated rays must be saved for this element */
    bool get_generated_save_state(const TElement &e);

    /** Set all save states to false */
    void clear_save_states();

    /** Get maximum intensity for a single ray FIXME */
    double get_max_ray_intensity() const;

    /* Get raytracing mode used FIXME */
    //  inline Tracer::Mode get_mode() const;

    /** Allocate a new Trace::Ray object from result */
    TTraceRay & new_ray();

    /** Allocate a new Trace::Ray object from result */
    TTraceRay & new_ray(const TRay &r);

    /** Declare a new ray interception */
    void add_intercepted(const TSurface &s, TTraceRay &ray);
    /** Declare a new ray generation */
    void add_generated(const TElement &s, TTraceRay &ray);

    /** Declare ray wavelen used for tracing */
    void add_ray_wavelen(double wavelen);

    /** Get ray wavelen in use set */
    const std::set<double> & get_ray_wavelen_set() const;

    /** Get reference to tracer parameters used */
    const TParams & get_params() const;

    /** Draw all tangential rays using specified renderer. Only rays
        which end up hitting the image plane are drawn when @tt
        hit_image is set. */
    void draw_2d(TRenderer &r, bool hit_image = false,
                 const TElement *ref = 0) const;
    /** Draw all rays using specified renderer. Only rays
        which end up hitting the image plane are drawn when @tt
        hit_image is set.*/
    void draw_3d(TRenderer &r, bool hit_image = false,
                 const TElement *ref = 0) const;

  private:
    void init(const TSystem &system);
    void init(const TElement &element);

    void prepare();

    struct element_result_s
    {
      rays_queue_t *_intercepted; // list of rays for each intercepted surfaces
      rays_queue_t *_generated; // list of rays for each generator surfaces
      bool _save_intercepted_list;
      bool _save_generated_list;
    };

    struct element_result_s & get_element_result(const TElement &e);
    const struct element_result_s & get_element_result(const TElement &e) const;

    vector_pool<TTraceRay, 256> _rays; // rays allocation pool
    std::vector<struct element_result_s> _elements;
    std::set<double>          _wavelengths;
    rays_queue_t              *_generated_queue;
    TResult::sources_t  _sources;
    unsigned int              _bounce_limit_count;
    const TSystem         *_system;
    const TParams       *_params;
    //  Tracer::Mode          _mode;
};

#endif // TRESULT_H
